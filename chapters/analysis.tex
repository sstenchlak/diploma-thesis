\chapter{Analysis and formal description}
\label{chapters:analysis}

\textit{This chapter analyzes several requirements for the software regarding framework layers and proposes modifications to them. As will be stated in the Implementation chapter \ref{chapters:implementation}, not everything is implemented yet due to its complexity, but it is crucial to properly design and plan everything in advance to minimize the technical debt.}

\section{CIM and PIM layers}

\begin{requirement}
    \label{requirement:ontologies-on-the-web}
    As many ontologies are located on the web in formats like OWL, RDFs, UFO, etc., the application shall support reading them. This has the following impacts:
    \begin{enumerate}
        \item The ontology may \textbf{not always be available}. Unavailability should not forbid us from generating the schemas and making minor changes to them if those changes are not directly related to reading the ontology.
        \item The ontology may \textbf{change unexpectedly}. As there are no strict requirements, we must not expect to get the history of modifications yet still be able to perform schema evolution in some semi-automatic way.
        \item The concepts in the ontology may \textbf{point to another ontology} according to Linked Open Data principles.
    \end{enumerate}
\end{requirement}

In contrast with the approach introduced in \textit{XCase} and \textit{eXolutio} tools, the process of creating the domain ontology is moved from the application to the external tools. The application then only uses those ontologies if required.

To support the first and second points, we modified the previously introduced five-level framework. We added new top-most level called CIM (from \textit{Computational Independent Model}). CIM represents the domain ontology. Although there can be more ontologies, with the LOD approach, we can see them as one. PIM is then used as a copy of CIM, and only the necessary entities are copied to PIM. This modification is in accordance with point 1 and gives us a base ground for implementing point 2, as we can compare CIM and PIM and try to create a sequence of operations that modifies PIM to be consistent with CIM.

\begin{requirement}
    \label{requirement:multiple-technologies}
    The application shall support multiple data formats and their validation languages (such as JSON Schema, XSD, and CSV schema), and it shall be possible to add support for others easily.
\end{requirement}

Although requirement \ref{requirement:multiple-technologies} mainly affects the PSM level, it also impacts the definition of an ontology. As we shall support all kinds of serialization technologies, some of them may not use all the information, which pushes us to define the ontology and PIM level in the most elementary way.

\begin{definition}[PIM] PIM is a triple $S=(S_c, S_a, S_r)$ of sets of classes, attributes and associations, respectively such that:
\begin{itemize}
    \item Attribute $A \in S_a$ belongs to class $C \in S_c$, which is denoted by anotation $\textrm{class}: S_a \rightarrow S_c$ as $\textrm{class}(A)=S$.
    \item Association $R \in S_r$ is a set of exactly two association ends ${E_1, E_2}$ that are associated with classes similarly as with attributes by $\textrm{class}: E \rightarrow S_c$.
\end{itemize}

\td{why PIM has this specific form? UFO and history}

We will call classes, attributes, and associations entities. PIM then can be decorated by various semantic and syntactic \textbf{annotations}. An annotation is a function on a subset of entity space. We do not require that anotation must be defined for every entity. Undefined annotation $a$ on entity $I$ will be formally denoted as $a(I) = \textrm{undefined}$.

\begin{itemize}
    \item Classes, attributes, associations, and association ends\footnote{Because two association ends belong to an association, we may annotate the association itself instead of their ends. However, to simplify things, we say that association ends may also have annotations.} may have title and description, or potentially other describing properties that are not directly used in schema generation. However, the title may be used to propose the naming of entities' labels at the PSM level. (For example $name(C)="\textrm{Tourist destination}"@en$)
    \item Attributes and association ends have cardinalities.
    \item Attributes have data types.
\end{itemize}

\end{definition}

\begin{definition}[interpretation]
    We say that PIM entity $I$ is interpreted if and only if $interpretation(I) \neq \emptyset$ and is defined.
\end{definition}

\begin{definition}[CIM]
CIM $O$ is an ontology database for which function \textbf{CIM adapter} $A$ exists, such that $A(O) = S$ is a valid PIM, where every entity $I$ is interpreted and the interpretation is unique, stable and consistent.
\end{definition}

The definition tells us, that CIM is everything that can be translated to PIM and that process is stable over time. If CIM is slightly changed, also the resulting PIM will be changed only slightly. If CIM is stored according to LOD format, than the $interpretation$ would be the URI of the CIM entity, that corresponds to the given PIM entity.

For simplification, in the rest of the thesis we may ommit that CIM \textit{needs to be translated} to PIM and suppose that is already in PIM-like format.




\newpage\subsection{User modifications on the PIM level}

\td{\begin{itemize}
        \item The override must exists all the time as it is not possible to "use old iri".
        \item simpliest would be to introduce $overrides$ anotation that has anotation itself, $deleted$ anotation and that would be all. Then introduce other PIM entities that can semantically map data between different entities.
        \item pros and cons
    \end{itemize}}

\begin{requirement}
    \label{requirement:pim-editing}
    The previous approach of creating the ontology directly in the application is not required, but there should be a support for \textit{some} modifications.
\end{requirement}

As stated in the requirement \ref{requirement:ontologies-on-the-web}, the usual scenario for data modelling consists of reading an ontology from the web as a CIM. This section analyzes the requirement \ref{requirement:pim-editing}, whether there exists scenarios, where modifying the ontology in the tool may be beneficial than modification of the ontology itself.

We can classify the reasons for modifying the ontology as follows:

\begin{enumerate}
    \item The ontology is wrong and does not describe the domain correctly. - \textit{Then the most correct way would be to fix the ontology.}
    \item The ontology describes only a subset of the domain. Either only the core of the domain, or the ontology is complete, but only for one domain, whether in another, something may missing. - \textit{If the desired ontology is strictly a superset of the domain, we can exploit the features of linked data to add missing anotations in our own structured data. Then, we would use the new ontology.}
    \item The ontology is not granular enough. Some entities can be represented in more details than currently are, or vice versa. - \textit{We would need to create a copy of affected classes or use advanced tool, if exists.}
\end{enumerate}

Suppose the example with goods in the delivery company. Although the goods may be identified by EAN (barcode on items), the software team may prefer their own iternal identifiers. There can be reasons for not including the identifier into the ontology, as it is too specific for only a software team. That would correspond to the second category from the list above. The third category may represents the case, when we, for example, need to replace an address with a set of more specific attributes such as \textit{street}, \textit{number}, \textit{city}, \textit{country}, etc.

Although in all the scenarios, the preffered way would be to create a new ontology, it can be too cumbersome and time consuming, especially if the change is too small. Therefore, it should be possible to somehow allow modifying the PIM.

\smallskip

In context of other requirements and the framework used, this would also mean that:
\begin{itemize}
    \item PIM that is not consistent with CIM and we do not intent to make it consistent can be "marked" as modified. This would stop proposing the user to evolute the schemas according to the newest CIM.
    \item If CIM changes, the semi-automatic update can respect modifications and ask the user for changes, that can not be performed automatically.
\end{itemize}

\smallskip

As a solution, we expose $interpretation$ and new $overrides$ anotation of PIM in a following way:

% \begin{definition}[overrides]
%     PIM anotation $overrides: i \mapsto j$, where $i$ is non-interpreted PIM entity, and $j$ is set of interpreted PIM entities denotes, that $j$-s are replaced by $i$. From the ontological point of view, $i$ then represents a subset of $j$. All entities from $j$ then must not be used in levels below.
% \end{definition}

\begin{definition}[overrides]
    PIM anotation $overrides: (i, a) \mapsto j$, where $i$ is interpreted PIM entity, $a$ is anotation other than $overrides$, and $j \in D(a)$ belongs to the domain of $a$, denotes locally overwritten anotations for given entity.
\end{definition}

$overrides$ anotation is used to introduce changes in interpreted entities as they should not be changed by user to not interact with detection of inconsistency.

Overriding can not be stacked and is not applicable to non-interpreted entities. Its purpose is to only fix entities that cannot be fixed directly. Overrides does not replace extensibility and vice versa. Extensibility adds more specific classes, whether overrides replace them.

\begin{definition}[deleted]
    PIM anotation $deleted: I \rightarrow \{\textrm{false}, \textrm{true}\}$, where $I$ is a set of interpreted classes, associations, and attributes, denotes that the interpreted entity is deleted and must not be used in the lower levels.
\end{definition}

As we say the PIM is a subset of CIM, simply deleting the entity would not be enough, as we would not know whether the entity is deleted or just not discovered. Deletion is purely cosmetic feature. It only forbids user to use it in the lower levels.

\begin{notation}
    Interpreted PIM entities with their anotations represents subset of CIM and are not modified directly in order to change the ontology\footnote{Meaning that interpreted entities corresponds to CIM and are used to store the "latest snapshot" of CIM.}. To modify interpreted entity, use overrides and delete anotations. Non-interpreted PIM entities then new concepts to the ontology.
\end{notation}

The list below summarizes common operations regarding this problematics:

\begin{itemize}
    \item Add attribute, association or class. - \textit{Create the corresponding PIM entitiy that has no interpretation. It may reference interpreted entities.}
    \item Remove attribute, association or class. - \textit{Set $deleted$ to true if the entity is interpreted, remove otherwise.}
    \item Modify label, description, cardinality and other properties - \textit{Modify the entity directly if is not interpreted. Otherwise, use overrides to set new values.}
\end{itemize}

\bigskip

There are alternative solutions to the proposed one. The first one is to create a new level between PIM and PSM with user modifications. Let's say User PIM, or UPIM shortly. UPIM would contain non interpreted entities and mapping to interpreted ones to PIM level. Removing an entity would then correspond to the missing mapping and overriding for the mapping with anotations. Although this solution may be cleaner from several aspects, it would introduce two levels with almost same functionality. Setting or unsetting an interptetation for the resouce would mean to move it between the levels and using ontology without modification would still require empty identities on UPIM level that are mapped to those in PIM.

\bigskip

\begin{definition}[consistency]
    %We say that \textbf{PIM is consistent with CIM}, if PIM is a subset of CIM.
    We say that \textbf{PIM is consistent with CIM}, if a set of all interpreted PIM entities is a subset of CIM.
\end{definition}

From the descriptions above, the inconsistency may happen only if the CIM changes. It is easy to detect it as we can compare entities in PIM with those in CIM. To support the \nth{2} point from requirement \ref{requirement:ontologies-on-the-web}, we would need to create a set of atomic operations on the PIM level that make the PIM consistent again. These operations can be propagated up to schemas to apply the change from the ontology.

\newpage\subsection{Evolution of interpreted, non-interpreted PIM entities and PIM entities with overrides}

To demonstrate, that the proposed solution may work, we show that some operation can be easily propagated in PIM level.

\td{Dát sem kódy co se má provést na PIMu, pokud:\begin{itemize}
    \item smaže se z CIMu entita.
    \item změní se anotace entity v CIMu.
    \item vznikne nová entita v CIMu, pak by se hodilo otestovat, jestli už neexistuje lokálně.
\end{itemize}}


\newpage
\subsection{Semantic mapping of related PIM entities}

The third reason of modifying an ontology from the previous subsection may be analyzed from another point of view. As we decide to introduce a new entity/entities, that replace others, it may be beneficial to keep the information that the two groups are semantically connected. This would probably tends us to extend PIM with semantic mapping between entities which can be used for transformations purposes.

As an example suppose the address again. Address as a whole can be mapped to its parts, such as street, number, etc and vice versa. The simpliest mapping would split the string by commas and new lines, and join them back, respectively.

The mapping may not be used just for new PIM entities, as we have shown, but also between the entities in the ontology or between different ontologies.

User then can decide, whether he/she wants to use the first, or the second group of entities and tranformation script would be still able to transform data between those two representations.

\begin{figure}[h]\centering
    \begin{tikzpicture}[
        class/.style={rectangle, draw=orange!60, fill=orange!5, very thick, minimum size=5mm},
        attribute/.style={rectangle, draw=blue!60, fill=blue!5, very thick, minimum size=5mm},
        mapping/.style={rectangle, draw=red!60, fill=red!5, very thick, minimum size=5mm},
    ]
        %Nodes
        \node[class,align=center] (ci) {\textbf{PIM class}\\Contact information};

        \node[attribute,align=center] (address) [below=.5cm of ci, xshift=2.5cm,anchor=north west] {\textbf{PIM attribute}\\address};

        \node[attribute,align=center] (as) [below=.5cm of ci, xshift=-2.5cm,anchor=north east] {\textbf{PIM attribute}\\street};
        \node[attribute,align=center] (an) [below=.5cm of as] {\textbf{PIM attribute}\\number};
        \node[attribute,align=center] (ac) [below=.5cm of an] {\textbf{PIM attribute}\\city};

        \node[mapping,align=center] (map) [below=3cm of ci, xshift=3cm, ,anchor=north] {\textbf{PIM mapping}\\\{address\}=\{street\}, \{number\}\textbackslash n\{city\}};
        \node (psmDot) [below=.5cm of ac] {...};

        %Lines
        \draw[latex-] (ci) -- (address.west);
        \draw[latex-] (ci) -- (as.east);
        \draw[latex-] (ci) -- (an.east);
        \draw[latex-] (ci) -- (ac.east);

        \draw[-latex] (map.north) -- (address.south);
        \draw[-latex] (map.west) -- (as.east);
        \draw[-latex] (map.west) -- (an.east);
        \draw[-latex] (map.west) -- (ac.east);
    \end{tikzpicture}
    \caption{Possible solution for the problem of semantic mapping between PIM entities. The example shows two groups of attributes that can be mapped on each other.}
\end{figure}

We will keep the question behind the mapping open as it is way too advanced for the current state of the project. Hovewer, introducing a new PIM construct to the framework, that maps the entities,  shoud not collide whith the rest of the framework and as it is in PIM level, it would be possible to extract this information from CIM.

\newpage\section{PSM layer}

\td{\begin{itemize}
    \item General definition - most unique
    \item analysis of basic constructs that may be used, OR and INCLUDE analysis
    \item News compared to old version - reuse
\end{itemize}}




\newpage\section{Whole framework structure}

\td{
    \begin{itemize}
        \item History of atomic operations is stored with the model because there is a requirement that we may have no access to everything + there is SOLID.
        \item Everything belongs to schema.
        \item Because of the first point in this list, the checks need to be performed differently, not during the evolution.
        \item Operations are stored and can be re-recorded - this allow us to work separately on different parts of the model and then apply the changes by evolution.
    \end{itemize}
}
