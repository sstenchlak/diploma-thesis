\chapter{Formal background}
\label{chapters:formal-background}

% Otazka, zda vychazet z ontologie, nebo z PIMu. Ontologie se da okopirovat z knihy, kde je popsano, jak vetsina ontologii vypada. Daji se tady take vyjmenovat a shrnout jejich vlastnosti. Na zaklade toho sestavit PIM.

This chapter proposes modification to the introduced framework layers and formally describes them. As will be stated in the chapter \ref{chapters:implementation} Implementation, not everything is implemented yet due to its complexity. Nevertheless, it is crucial to properly design and plan everything in advance to minimize the technical debt.

\medskip

In contrast with the approach introduced in \textit{XCase} and \textit{eXolutio} tools, the process of creating the domain ontology is moved from the application to the external tools. The application then only uses those ontologies if required.

To support the first and second points, we modified the previously introduced five-level framework. We added new top-most level called CIM (from \textit{Computational Independent Model}). CIM represents the remote ontology on the web. Although there can be more ontologies, with the LOD approach, we can see them as one. PIM is then used as a copy of CIM, and only the necessary entities are copied to it, which corresponds to the previous tools whose ontology was stored in PIM. This modification is in accordance with point 1 and gives us a base ground for implementing point 2, as we can compare CIM and PIM and try to create a sequence of operations that modifies PIM to be consistent with CIM again.

\smallskip

\begin{definition}[PIM] PIM is a triple $S=(S_c, S_a, S_r)$ of sets of classes, attributes and associations, respectively (we will call them as entities), with a set of anotation functions such that:
    \begin{itemize}
        \item Attribute $A \in S_a$ belongs to class $C \in S_c$, which is denoted by anotation function ${class}: S_a \rightarrow S_c$ as ${class}(A)=S$.
        \item Association $R \in S_r$ is a set of exactly two association ends ${E_1, E_2}$ that are associated with classes similarly as with attributes by annotation function ${class}: E \rightarrow S_c$.
    \end{itemize}

    PIM then can be decorated by other various semantic and syntactic annotations as it can be seen from the definition above. We do not require that an annotation must be defined for every entity if not stated otherwise. %Undefined annotation $a$ on entity $I$ will be formally denoted as $a(I) = \textrm{undefined}$.

    \begin{itemize}
        \item Classes, attributes, associations, and association ends\footnote{Because two association ends belong to an association, we may annotate the association itself instead of their ends. However, to simplify things, we say that association ends may also have annotations.} may have title and description, or potentially other describing properties that are not directly used in schema generation. However, the title may be used to propose the naming of entities' labels at the PSM level. (For example $name(C)="\textrm{Tourist destination}"@en$)
        \item Classes have a set of other classes that they extends by anotation $extends: S_c \rightarrow \mathcal{P}(S_c)$.
        \item Attributes and association ends have cardinalities $card_{min}: S_a \cup E \rightarrow \mathds{N}_0$ and $card_{max}: S_a \cup E \rightarrow \mathds{N} \cup \{\infty\}$, where $card_{min}(i) \leq card_{max}$, where the comparison operator works same as in the extended real number system.
        \item Attributes have data types $datatype: S_a \rightarrow D$ where $D$ is a set of data types, usually specified by a IRI.
    \end{itemize}
\end{definition}

%why PIM has this specific form?

\smallskip

\begin{definition}[interpretation]
    Let us have an anotation $interpretation: E \rightarrow \mathcal{C} \cup \{\emptyset\}$ from all entities to $\mathcal{C}$, set of all entities in CIM denoted by its IRI. We say that PIM entity $I$ is interpreted if and only if anotation $interpretation(I) \neq \emptyset$.
\end{definition}

Interpretation defines, whether the PIM entity represents an entity from CIM, that means that the entity is a copy from CIM and semantically represents the same thing. Non-interpreted entities on PIM level are those, that were added by a user manually usually to add missing thing that was not present in the CIM.

\smallskip

\begin{definition}[CIM]
    CIM $O$ is an ontology for which function \textbf{CIM adapter} $A$ exists, such that $A(O) = S$ is a valid PIM, where every entity $I$ is interpreted, and the interpretation is unique, stable, and consistent.
\end{definition}

The definitions tell us that CIM is everything that can be translated to PIM and that process is stable over time. If one entity in CIM is changed, also the resulting PIM should have changed the corresponding entity. If CIM is stored according to LOD format, then the $interpretation$ would be the URI of the CIM entity that corresponds to the given PIM entity.

For simplification, in the rest of the thesis, we may omit that CIM \textit{needs to be translated} to PIM and suppose that it is already in PIM-like format.

\bigskip

To analyze the relation between CIM and PIM

% cim neni lokalni, pim je vzdy up to date
% nejake modifikace dovolime

% dedicnost

%\newpage\subsection{Hierarchy on the PIM level}




\newpage\subsection{User modifications on the PIM level and evolution from CIM}

This issue must be analyzed concurrently with the second point of requirement \ref{requirement:ontologies-on-the-web}, that the ontology may change. Ideally, the changes in CIM should be reflected in the resulting schemas; therefore we need a mechanism that tells us what has changed. Having PIM strictly as a copy of CIM may help in this process as we can compare the two levels and \textit{somehow} generate a sequence of operations that modifies PIM. The modifications may be as simple as \textit{changing a class title}, or \textit{changing an association cardinality} to the complex ones such as \textit{join two attributes into one} or \textit{move an attribute to another class}. It is essential to have the changes that complex as they carry the information on how the schemas and their data should be modified, not just the final state.

Direct modification of PIM may break this approach because the mechanism that tells us what has changed would also try to revert all the changes made by the user. To be more specific, we are interested only in those entities that have interpretation - entities that are linked to CIM. All other non-interpreted entities can be just ignored as they were not created from the CIM.

Formally, it may seem that changing an interpreted entity (and still keeping it interpreted) should not be allowed as the changed entity itself does not represent the ontology anymore. As this may be true, there are still some cases when the change is necessary, especially when the CIM does not give us all the information we need (such as missing cardinality or missing description) or there is an obvious error that needs to be fixed.

We will keep the question of what changes are large enough to lose the entity's interpretation open for further discussion.

This observation, together with the fact that we would have to anyway infer the operations from the difference between CIM and PIM, leads us to a simple solution of allowing a user to modify everything and then prompt him/her to apply only the changes that are relevant.

In the context of other requirements and the framework used, this would also mean that:
\begin{itemize}
    \item PIM entity that is not consistent with CIM and we do not intend to make it consistent can be uninterpreted. This would stop proposing the user to evolute the schemas according to the newest CIM.
    \item If CIM changes, the semi-automatic update can respect modifications and ask the user for changes that can not be performed automatically.
\end{itemize}

To make modifications complete, we also need to delete the entities. As we say, the PIM is a subset of CIM, simply deleting the entity would not be enough, as we would not know whether the entity is deleted or just not discovered. Therefore we introduce a new annotation that marks the entity as deleted. Deletion is a purely cosmetic feature, as, without it, the sufficient approach would be to ignore the entity. It only forbids users to use it in the lower levels.

\begin{definition}[deleted]
    PIM annotation $deleted: I \rightarrow \{\textrm{false}, \textrm{true}\}$, where $I$ is a set of interpreted classes, associations, and attributes, denotes that the interpreted entity is deleted and must not be used in the lower levels.
\end{definition}

%\smallskip

%To make things complete,

%As a solution, we expose $interpretation$ and new $overrides$ anotation of PIM in a following way:

% \begin{definition}[overrides]
%     PIM anotation $overrides: i \mapsto j$, where $i$ is non-interpreted PIM entity, and $j$ is set of interpreted PIM entities denotes, that $j$-s are replaced by $i$. From the ontological point of view, $i$ then represents a subset of $j$. All entities from $j$ then must not be used in levels below.
% \end{definition}

% \begin{definition}[overrides]
%     PIM anotation $overrides: (i, a) \mapsto j$, where $i$ is interpreted PIM entity, $a$ is anotation other than $overrides$, and $j \in D(a)$ belongs to the domain of $a$, denotes locally overwritten anotations for given entity.
% \end{definition}

% $overrides$ anotation is used to introduce changes in interpreted entities as they should not be changed by user to not interact with detection of inconsistency.

% Overriding can not be stacked and is not applicable to non-interpreted entities. Its purpose is to only fix entities that cannot be fixed directly. Overrides does not replace extensibility and vice versa. Extensibility adds more specific classes, whether overrides replace them.

% \begin{definition}[deleted]
%     PIM anotation $deleted: I \rightarrow \{\textrm{false}, \textrm{true}\}$, where $I$ is a set of interpreted classes, associations, and attributes, denotes that the interpreted entity is deleted and must not be used in the lower levels.
% \end{definition}

% As we say the PIM is a subset of CIM, simply deleting the entity would not be enough, as we would not know whether the entity is deleted or just not discovered. Deletion is purely cosmetic feature. It only forbids user to use it in the lower levels.

% \begin{notation}
%     Interpreted PIM entities with their anotations represents subset of CIM and are not modified directly in order to change the ontology\footnote{Meaning that interpreted entities corresponds to CIM and are used to store the "latest snapshot" of CIM.}. To modify interpreted entity, use overrides and delete anotations. Non-interpreted PIM entities then new concepts to the ontology.
% \end{notation}

% The list below summarizes common operations regarding this problematics:

% \begin{itemize}
%     \item Add attribute, association or class. - \textit{Create the corresponding PIM entitiy that has no interpretation. It may reference interpreted entities.}
%     \item Remove attribute, association or class. - \textit{Set $deleted$ to true if the entity is interpreted, remove otherwise.}
%     \item Modify label, description, cardinality and other properties - \textit{Modify the entity directly if is not interpreted. Otherwise, use overrides to set new values.}
% \end{itemize}

% \bigskip

% There are alternative solutions to the proposed one. The first one is to create a new level between PIM and PSM with user modifications. Let's say User PIM, or UPIM shortly. UPIM would contain non interpreted entities and mapping to interpreted ones to PIM level. Removing an entity would then correspond to the missing mapping and overriding for the mapping with anotations. Although this solution may be cleaner from several aspects, it would introduce two levels with almost same functionality. Setting or unsetting an interptetation for the resouce would mean to move it between the levels and using ontology without modification would still require empty identities on UPIM level that are mapped to those in PIM.

%\smallskip

\begin{definition}[consistency]
    We say that \textbf{annotation of interpreted PIM entity is consistent with CIM} if the CIM entity exists and the value is equal to the value in CIM or in the context of the annotation is a superset\footnote{Consider, for example, $extends$. As we want PIM to be a subset, we also allow $extends$ to be a subset of all classes that the given class exteds.} of the value in CIM. We say that \textbf{interpreted PIM entity is consistent with CIM} if the CIM entity exists and all annotations are consistent with CIM.
\end{definition}

From the descriptions above, the inconsistency may happen if the CIM changes or when user modifies the PIM. It is easy to detect it as we can compare entities in PIM with those in CIM. To support the second point from requirement \ref{requirement:ontologies-on-the-web}, we would need to create a set of atomic operations on the PIM level that make the PIM consistent again. These operations can be propagated up to schemas to apply the change from the ontology.

\td{Chtěl bych ještě zmínit alternativní řešení nad kterýma jsem přemýšlel a zjistil jsem, že jsou z nějakého důvodu špatná.}

\newpage\subsection{Evolution of interpreted and non-interpreted PIM entities}

To demonstrate that the proposed solution may work, we show how some operations may be correctly executed on the PIM level. Suppose we have a sequence of operations that need to be executed on interpreted PIM entities to be consistent with CIM.

\td{Dát sem kódy co se má provést na PIMu, pokud:\begin{itemize}
    \item smaže se z CIMu entita. Předtím, než smažu třídu, tak musím smazat zbytek jejich atributů a asociací, ty určitě nejsou interpretovány, protože interpretované byly smazány.
    \item změní se anotace entity v CIMu. Zeptej se uživatele, jestli ji chce změnit
    \item vznikne nová entita v CIMu, pak by se hodilo otestovat, jestli už neexistuje lokálně.
\end{itemize}}


\newpage\subsection{Making PIM consistent with CIM}

\td{Tady bych navrhl, jak by se mohl PIM zkonzistentnit. Asi by to bylo tak, že se pokusím vyrobit množinu nezávislých změn v PIMu (tady se změnila třída, tady se rozpadl atribut), kdy u každé změny si uživatel vybere, jestli ji provede, nebo ne. Samozřejmě že bych zatím implementoval jen ty jednoduché změny, u ostatních by to napsalo, že neví, co s tím. Otázkou tedy akorát zůstává, jestli tomuto směru aktuálně věnovat energii. (pokud je vůbec správně a nemám v tady nějakou myšlenkovou chybu)}







\newpage\section{PSM layer}

\td{\begin{itemize}
    \item General definition - most unique
    \item analysis of basic constructs that may be used, OR and INCLUDE analysis
    \item News compared to old version - reuse
\end{itemize}}

% Pravidlo, že z venku se dá odkazovat pouze na kořen
% Vevnitř můžeme odkazovat kdekoli
% Zase pozor, abych nevymýšlel něco, co už udělal Nečaský.
% Příklady operací co máme, důkaz, že dokážeme s nimi udělat vše?
% PSM specific attributes, jako XML namespace, který se již používá


\newpage\subsection{OR and handling of hierarchy}




\newpage\section{Whole framework structure}

\td{
    \begin{itemize}
        \item History of atomic operations is stored with the model because there is a requirement that we may have no access to everything + there is SOLID.
        \item Everything belongs to schema.
        \item Because of the first point in this list, the checks need to be performed differently, not during the evolution.
        \item Operations are stored and can be re-recorded - this allow us to work separately on different parts of the model and then apply the changes by evolution.
    \end{itemize}
}
