\chapter{Formal background}
\label{chapters:formal-background}

This chapter proposes modifications to the framework layers introduced by previous tools \textit{xCase} and \textit{eXolutio} and formally describes them. Some problems are further analyzed as the reasoning depends on the framework structure and not just user requirements.

As mentioned in the previous chapter, not everything has been implemented yet due to the complexity of the problem. Nevertheless, it is crucial to properly design and plan everything in advance to minimize the technical debt.

\section{Conceptual layers}

In contrast with the approach introduced in \textit{XCase} and \textit{eXolutio} tools, the process of creating the domain ontology is moved from the application to the external tools. The application then only uses those ontologies if required.

To fullfil the introduced requirements, we have modified the previously introduced five-level framework in the following way:
\begin{itemize}
    \item We have added a new top-most level called \textbf{CIM} (from \textit{Computational Independent Model}). CIM represents the remote ontology on the web according to \autoref{requirement:ontologies-on-the-web}. Although the level is part of the framework, it is important to stress that it has no direct representation in the code because the data are stored on the internet. Because we suppose ontologies respect LD principles, we can see them as one.
    \item Previous \textbf{PIM} layer is used as a copy of the CIM layer, and only the necessary entities are copied to it. This approach is compatible with the design of the previous tools, which used PIM as the source of the ontology.
\end{itemize}

This modification, brings several advantages:
\begin{enumerate}
    \item As the ontology is copied, this allows us to use the tool seamlessly without depending on the ontology. We can generate artifacts and modify the schema. Only the operations related to directly using the ontology depend on CIM.
    \item The mechanism that derives a list of changes during the evolution (see \autoref{requirement:evolution}) may use the PIM layer as a comparison.
    \item The layer still separates the ontology from the rest of the model, simplifying the design of the whole framework. For example, the other layers may refer to information in PIM.
\end{enumerate}

\bigskip

We will start with definition of PIM, as the CIM depends on it.

\begin{definition}[PIM] PIM is a triple $S=(S_c, S_a, S_r)$ of sets of classes, attributes and associations, respectively (we will call them as entities), with a set of anotation functions such that:
    \begin{itemize}
        \item Attribute $A \in S_a$ belongs to class $C \in S_c$, which is denoted by anotation function ${class}: S_a \rightarrow S_c$ as ${class}(A)=S$.
        \item Association $R \in S_r$ is a tuple of exactly two association ends $(E_1, E_2)$ that are associated with classes similarly as with attributes by annotation function ${class}: E \rightarrow S_c$.
    \end{itemize}

    PIM entities then can be decorated by other various semantic and syntactic annotations. We do not require that an annotation must be defined for every entity if not stated otherwise.

    \begin{itemize}
        \item Classes, attributes, associations, and association ends\footnote{Because two association ends belong to an association, we may annotate the association itself instead of their ends. However, to simplify things, we say that association ends may also have annotations.} may have title and description, or potentially other describing properties that are not directly used in schema generation. However, the title may be used to propose the naming of entities' labels at the PSM level. (For example $title(C)="\textrm{Tourist destination}"@en$)
        \item Each class have a set of classes that they extends by anotation $extends: S_c \rightarrow \mathcal{P}(S_c)$. (see \autoref{requirement:inheritance})
        \item Attributes and association ends have cardinalities $card_{min}: S_a \cup E \rightarrow \mathds{N}_0$ and $card_{max}: S_a \cup E \rightarrow \mathds{N} \cup \{\infty\}$, where $card_{min}(i) \leq card_{max}$, where the comparison operator works same as in the extended real number system.
        \item Attributes have data types $datatype: S_a \rightarrow D$ where $D$ is a set of data types, usually specified by a IRI.
    \end{itemize}
\end{definition}

The purpose of annotations is to bring additional information to the model that is not essential for the generation. As we stated in the previous chapter, there are various ontologies, and some of them may lack support of some construct. We have already mentioned that RDFS does not allow naming the reverse direction of an association. Some ontologies may not support cardinalities or inheritance (although most of them do). Similarly, some artifacts may not use all every information from PIM. For example, data transformations do not need title and description to work with.

We do not provide a complete list of all annotations as the intention is to let programmers use their own if necessary, either when creating a new generator or adding support for the new format of an ontology.

\bigskip

Because during the modeling process, CIM (specifically ontologies under different formats) is being copied to PIM, it would make sense to define the CIM in a way that is compatible with PIM.

First, we need to define an interpretation that will be used to connect entities from PIM with those in CIM.

\begin{definition}[interpretation]
    Let us have an anotation $interpretation: E \rightarrow \mathcal{C} \cup \{\emptyset\}$ from all entities to $\mathcal{C}$, set of all IRI identifiers. We say that PIM entity $I$ is interpreted if and only if anotation $interpretation(I) \neq \emptyset$.
\end{definition}

\begin{definition}[CIM]
    CIM $O$ is an ontology for which function \textbf{CIM adapter} $A$ exists, such that $A(O) = S$ is a valid PIM, where every PIM entity has different defined interpretation which represents semantically corresponding CIM entity and that interpretation is stable over time. That means if CIM entity is changed, but represent semantically same thing, then the interpretation of the corresponding PIM entity shall stay same.
\end{definition}

The definition tells us that the CIM can be viewed as a PIM where the purpose of the interpretation is to point to the original thing in the ontology. In practice, it is the IRI of the entity in the ontology.

If the CIM changes, entities shall keep their original IRIs to stress that the given entity is semantically still the same. Only the representation may have changed. This will help us, for example, to detect changes and properly propagate them in the model.

For simplification, in the rest of the thesis, we may omit that CIM \textit{needs to be translated} to PIM and suppose that it is already in PIM-like format.

\subsection{Changes in CIM}

So far, we have introduced PIM and CIM layers and only tackled how the framework would work. Before we move further, we will analyze how \autoref{requirement:evolution} and \ref{requirement:pim-editing} would impact the framework.

Because the CIM is used only for building the PIM, the tool does not need to know that the ontology has changed as it works mostly only with PIM. However, to further expand the schema, the tool must fetch other parts of the ontology, which may collide with the PIM.

Having PIM strictly as a copy of CIM may help in this process as we can compare the two levels and, based on the difference \textit{somehow} generate a sequence of operations that modifies the PIM. The modifications may be as simple as \textit{changing a class title}, or \textit{changing an association cardinality} to the complex ones such as \textit{join two attributes into one} or \textit{move an attribute to another class}. It is essential to have the changes that complex as they carry the information on how the schemas and their data should be modified, not just the final state. We will describe operations later.

To formally describe the difference, we will introduce the concept of consistency.

\begin{definition}[consistency]
    We say that {annotation of interpreted PIM entity is consistent with CIM} if the corresponding CIM entity exists and the value is equal to the value in CIM or in the context of the annotation is a superset\footnote{Consider, for example, $extends$. As we want PIM to be a subset, we also allow $extends$ to be a subset of all classes that the given class extends.} of the value in CIM. We say that {interpreted PIM entity is consistent with CIM} if the CIM entity exists and all annotations are consistent with CIM. Finally, {PIM is consistent with CIM} if all entities are consistent.
\end{definition}

Based on the use case, most of the changes in the CIM that are worth propagating are simple and well-isolated. This may ease the process of inferring changes between PIM and CIM by finding those isolated sets of entities and then creating a sequence of changes based on a predefined set of rules.

As mentioned, for complex changes, it would be easier to generate "delete and create" a set of operations, which should remove the entities from created schemas after propagating. This allows users to add new entities to the schemas that were cleaned from outdated entities.

\medskip

We will leave the problematics of making PIM consistent for the author's further work. So far, we will suppose that the CIM is constant and cannot be changed.

\subsection{User modifications}

Direct modification of PIM (see \autoref{requirement:pim-editing}) may break the previous approach because the mechanism that tells us what has changed would also try to revert all the changes made by the user.

To be more specific, we are interested only in those entities that have interpretation - entities that are linked to CIM. All other non-interpreted entities are so far ignored.

Formally, it may seem that changing an interpreted entity (and still keeping it interpreted) should not be allowed as the changed entity itself does not represent the ontology anymore. As this may be true, there are still some cases when the change is necessary, especially when the CIM does not give us all the information we need (such as missing cardinality or missing description), or there is an obvious error that needs to be fixed.

\medskip

Nevertheless, we expect only minimal changes to be made by the user because of the abovementioned reasons. Due to the same reasons, those user modifications shall be checked every time the PIM is being made consistent because the change in the ontology may fix the same problem as the user modification.

Because of that, we allow editing of the PIM directly as this is the simplest option that will satisfy the requirements under the expected use case.

Create and update operations are simple and are summarized below. To make modifications complete, we also need to delete the entities. As we say, the PIM is a subset of CIM, simply deleting the entity would not be enough, as we would not know whether the entity is deleted or just not discovered. Therefore we introduce a new annotation that marks the entity as deleted. Deletion is a purely cosmetic feature, as, without it, the sufficient approach would be to ignore the entity. It only forbids users to use it in the lower levels.

\begin{definition}[deleted]
    PIM annotation $deleted: I \rightarrow \{\textrm{false}, \textrm{true}\}$, where $I$ is a set of interpreted classes, associations, and attributes, denotes that the interpreted entity is deleted and must not be used in the lower levels.
\end{definition}

\medskip

The introduced approach provides us with the following options for modifying the PIM:
\begin{itemize}
    \item We can create new entities by simply adding them to the PIM without interpretation.
    \item Existing entities can be edited directly and keeping them interpreted. This, however, will collide with the evolution mechanism and must be explicitly excluded from it every time the evolution is performed.
    \item To remove the interpreted entity, we must mark it as deleted. Non-interpreted entities can be removed directly.
\end{itemize}


%why PIM has this specific form?
% Otazka, zda vychazet z ontologie, nebo z PIMu. Ontologie se da okopirovat z knihy, kde je popsano, jak vetsina ontologii vypada. Daji se tady take vyjmenovat a shrnout jejich vlastnosti. Na zaklade toho sestavit PIM.

% cim neni lokalni, pim je vzdy up to date
% nejake modifikace dovolime

% dedicnost


%As a solution, we expose $interpretation$ and new $overrides$ anotation of PIM in a following way:

% \begin{definition}[overrides]
%     PIM anotation $overrides: i \mapsto j$, where $i$ is non-interpreted PIM entity, and $j$ is set of interpreted PIM entities denotes, that $j$-s are replaced by $i$. From the ontological point of view, $i$ then represents a subset of $j$. All entities from $j$ then must not be used in levels below.
% \end{definition}

% \begin{definition}[overrides]
%     PIM anotation $overrides: (i, a) \mapsto j$, where $i$ is interpreted PIM entity, $a$ is anotation other than $overrides$, and $j \in D(a)$ belongs to the domain of $a$, denotes locally overwritten anotations for given entity.
% \end{definition}

% $overrides$ anotation is used to introduce changes in interpreted entities as they should not be changed by user to not interact with detection of inconsistency.

% Overriding can not be stacked and is not applicable to non-interpreted entities. Its purpose is to only fix entities that cannot be fixed directly. Overrides does not replace extensibility and vice versa. Extensibility adds more specific classes, whether overrides replace them.

% \begin{definition}[deleted]
%     PIM anotation $deleted: I \rightarrow \{\textrm{false}, \textrm{true}\}$, where $I$ is a set of interpreted classes, associations, and attributes, denotes that the interpreted entity is deleted and must not be used in the lower levels.
% \end{definition}

% As we say the PIM is a subset of CIM, simply deleting the entity would not be enough, as we would not know whether the entity is deleted or just not discovered. Deletion is purely cosmetic feature. It only forbids user to use it in the lower levels.

% \begin{notation}
%     Interpreted PIM entities with their anotations represents subset of CIM and are not modified directly in order to change the ontology\footnote{Meaning that interpreted entities corresponds to CIM and are used to store the "latest snapshot" of CIM.}. To modify interpreted entity, use overrides and delete anotations. Non-interpreted PIM entities then new concepts to the ontology.
% \end{notation}

% The list below summarizes common operations regarding this problematics:

% \begin{itemize}
%     \item Add attribute, association or class. - \textit{Create the corresponding PIM entitiy that has no interpretation. It may reference interpreted entities.}
%     \item Remove attribute, association or class. - \textit{Set $deleted$ to true if the entity is interpreted, remove otherwise.}
%     \item Modify label, description, cardinality and other properties - \textit{Modify the entity directly if is not interpreted. Otherwise, use overrides to set new values.}
% \end{itemize}

% \bigskip

% There are alternative solutions to the proposed one. The first one is to create a new level between PIM and PSM with user modifications. Let's say User PIM, or UPIM shortly. UPIM would contain non interpreted entities and mapping to interpreted ones to PIM level. Removing an entity would then correspond to the missing mapping and overriding for the mapping with anotations. Although this solution may be cleaner from several aspects, it would introduce two levels with almost same functionality. Setting or unsetting an interptetation for the resouce would mean to move it between the levels and using ontology without modification would still require empty identities on UPIM level that are mapped to those in PIM.

%\smallskip

%
%\td{Chtěl bych ještě zmínit alternativní řešení nad kterýma jsem přemýšlel a zjistil jsem, že jsou z nějakého důvodu špatná.}
%
%\newpage\subsection{Evolution of interpreted and non-interpreted PIM entities}
%
%To demonstrate that the proposed solution may work, we show how some operations may be correctly executed on the PIM level. Suppose we have a sequence of operations that need to be executed on interpreted PIM entities to be consistent with CIM.
%
%\td{Dát sem kódy co se má provést na PIMu, pokud:\begin{itemize}
%    \item smaže se z CIMu entita. Předtím, než smažu třídu, tak musím smazat zbytek jejich atributů a asociací, ty určitě nejsou interpretovány, protože interpretované byly smazány.
%    \item změní se anotace entity v CIMu. Zeptej se uživatele, jestli ji chce změnit
%    \item vznikne nová entita v CIMu, pak by se hodilo otestovat, jestli už neexistuje lokálně.
%\end{itemize}}
%
%
%\newpage\subsection{Making PIM consistent with CIM}
%
%\td{Tady bych navrhl, jak by se mohl PIM zkonzistentnit. Asi by to bylo tak, že se pokusím vyrobit množinu nezávislých změn v PIMu (tady se změnila třída, tady se rozpadl atribut), kdy u každé změny si uživatel vybere, jestli ji provede, nebo ne. Samozřejmě že bych zatím implementoval jen ty jednoduché změny, u ostatních by to napsalo, že neví, co s tím. Otázkou tedy akorát zůstává, jestli tomuto směru aktuálně věnovat energii. (pokud je vůbec správně a nemám v tady nějakou myšlenkovou chybu)}
%
%


%
%
%
%\newpage\section{PSM layer}
%
%\td{\begin{itemize}
%    \item General definition - most unique
%    \item analysis of basic constructs that may be used, OR and INCLUDE analysis
%    \item News compared to old version - reuse
%\end{itemize}}
%
% Pravidlo, že z venku se dá odkazovat pouze na kořen
% Vevnitř můžeme odkazovat kdekoli
% Zase pozor, abych nevymýšlel něco, co už udělal Nečaský.
% Příklady operací co máme, důkaz, že dokážeme s nimi udělat vše?
% PSM specific attributes, jako XML namespace, který se již používá


%\newpage\subsection{OR and handling of hierarchy}



%
%\newpage\section{Whole framework structure}
%
%\td{
%    \begin{itemize}
%        \item History of atomic operations is stored with the model because there is a requirement that we may have no access to everything + there is SOLID.
%        \item Everything belongs to schema.
%        \item Because of the first point in this list, the checks need to be performed differently, not during the evolution.
%        \item Operations are stored and can be re-recorded - this allow us to work separately on different parts of the model and then apply the changes by evolution.
%    \end{itemize}
%}
%